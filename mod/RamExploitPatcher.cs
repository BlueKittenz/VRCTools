using ExitGames.Client.Photon;
using Harmony;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using VRCModLoader;


/*
RAM Exploit Packet:

Packet 200:
 - 245: [ExitGames.Client.Photon.Hashtable]:
 - | - 5: [Byte]: 8
 - | - 4: [DictionaryEntry]:
 - |   | [DIPHJLDJBCF]: [200000000 SendRPC/Always w: 128 s: BlockStateChangeRPC i: 0 f: 0 b: Unused B: 242 p: /_Application/ModerationManager]
 - | - 2: [Int32]: 313265536
 - | - 0: [Int32]: 1
 - 254: [System.Int32] 128

Here the VRC_EventLog.EventLogEntry.CombinedNetworkId value is defined to 200000000, and it should be defined to 0.
*/

namespace VRCTools
{
    internal class RamExploitPatcher
    {
        private static FieldInfo eventLogEntryGetter;

        internal static void Patch() // TODO: Optimise this crap
        {
            //APMDPMJMOCD.DBBLBDCLNHJ = FJALLEGMKMA.Full;

            VRCModLogger.Log("[RamExploitPatcher] Creating Harmony instance");
            HarmonyInstance harmonyInstance = HarmonyInstance.Create("vrctools.ramexploitpatcher");
            
            VRCModLogger.Log("[RamExploitPatcher] Looking for NetworkingPeer.OnEvent method");
            Type[] typesInAssembly = typeof(QuickMenu).Assembly.GetTypes();
            MethodInfo method = null;

            foreach(Type type in typesInAssembly)
            {
                if (type.Name != "PunTurnManager")
                {
                    method = type.GetMethod("OnEvent", BindingFlags.Public | BindingFlags.Instance);
                    if (method != null) break;
                }
            }
            
            if (method != null)
            {
                VRCModLogger.Log("[RamExploitPatcher] Patching NetworkingPeer.OnEvent");
                harmonyInstance.Patch(method, null, null, new HarmonyMethod(typeof(RamExploitPatcher).GetMethod("OnEventPatcher", BindingFlags.NonPublic | BindingFlags.Static)));
                VRCModLogger.Log("[RamExploitPatcher] Patch applied !");
            }
            else VRCModLogger.LogError("[RamExploitPatcher] Unable to found method NetworkingPeer.OnEvent !");
            
        }
        

        private static IEnumerable<CodeInstruction> OnEventPatcher(ILGenerator ilg, IEnumerable<CodeInstruction> instructions)
        {
            if(instructions.Count() != 923)
            {
                VRCModLogger.Log("[RamExploitPatcher] NetworkingPeer.OnEvent seems to have been modified. Patch disabled to avoid weird bugs.");
                return instructions;
            }
            CodeInstruction[] newInst = new CodeInstruction[instructions.Count() + 4];
            int offset = 0;
            bool done = false;
            for (int i = 0; i < newInst.Length - 4; i++)
            {
                CodeInstruction instruction = instructions.ElementAt(i);
                //VRCModLogger.Log("[RamExploitPatcher] Instruction " + i + ": " + instruction);
                if (instruction.opcode == OpCodes.Ldc_I4_M1 && !done)
                {
                    done = true;
                    VRCModLogger.Log("[RamExploitPatcher] Injecting instructions to list");

                    CodeInstruction ci1 = new CodeInstruction(OpCodes.Ldarg_1);
                    ci1.labels.Add(instruction.labels[0]);
                    newInst[i + (offset++)] = ci1;
                    
                    newInst[i + (offset++)] = new CodeInstruction(OpCodes.Callvirt, AccessTools.Method(typeof(RamExploitPatcher), "PhotonOnEvent"));
                    
                    Label label = ilg.DefineLabel();
                    newInst[i + (offset++)] = new CodeInstruction(OpCodes.Brtrue_S, label);
                    instruction.labels.Remove(instruction.labels[0]);
                    instruction.labels.Add(label);

                    newInst[i + (offset++)] = new CodeInstruction(OpCodes.Ret);
                    VRCModLogger.Log("[RamExploitPatcher] Injection done !");
                }

                newInst[i + offset] = instruction;

            }
            /*
            VRCModLogger.Log("[RamExploitPatcher] Done. Patched IL:");
            foreach(CodeInstruction instruction in newInst)
                VRCModLogger.Log("[RamExploitPatcher] | " + instruction);
            */

            return newInst.AsEnumerable();
        }


        
        public static bool PhotonOnEvent(EventData photonEvent)
        {
            try
            {
                if (photonEvent.Code == 200)
                {
                    if (photonEvent.Parameters.TryGetValue(245, out object hashtable))
                    {
                        if (((Hashtable)hashtable).TryGetValue((byte)4, out object dicEntry_))
                        {
                            object[] dicEntry = (object[])dicEntry_;
                            /* OLD CODE, FAIL ACROSS UPDATES
                            if (dicEntry[0].GetType() == typeof(VRC_EventLog.DIPHJLDJBCF))
                            {
                                VRC_EventLog.DIPHJLDJBCF eventLogEntry = (VRC_EventLog.DIPHJLDJBCF)dicEntry[0];
                                if (eventLogEntry.GFJCLHMFEJC != 0)
                                {
                                    VRCModLogger.Log("[RamExploitPatcher] Packet contains VRC_EventLog.EventLogEntry with CombinedNetworkId " + eventLogEntry.GFJCLHMFEJC);
                                    return false;
                                }
                            }
                            else VRCModLogger.Log("[RamExploitPatcher] Packet 200 doesn't contains VRC_EventLog.EventLogEntry");
                            */
                            long combinedId = GetCombinedId(dicEntry[0]);
                            if (combinedId != 0)
                            {
                                VRCModLogger.Log("[RamExploitPatcher] Packet contains VRC_EventLog.EventLogEntry with CombinedNetworkId " + combinedId);
                                return false;
                            }
                        }
                        else VRCModLogger.Log("[RamExploitPatcher] Packet 200 doesn't contains hashtable index 4");
                    }
                    else VRCModLogger.Log("[RamExploitPatcher] Packet 200 doesn't contains index 245");
                }
            }
            catch (Exception e) { VRCModLogger.LogError("[PhotonLogFull] " + e); }
            return true;
        }

        private static long GetCombinedId(object eventLogEntry)
        {
            if (eventLogEntry.GetType().IsArray)
            {
                VRCModLogger.Log("[RamExploitPatcher] Packet contains array of VRC_EventLog.EventLogEntry");
                return 0;
            }
            if (eventLogEntryGetter == null)
            {
                VRCModLogger.Log("[RamExploitPatcher] Looking for VRC_EventLog.EventLogEntry.get_CombineId");
                FieldInfo[] eventLogEntryGetterList = eventLogEntry.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
                VRCModLogger.Log("[RamExploitPatcher] Public instance types in " + eventLogEntry.GetType() + " :");
                foreach (FieldInfo fi in eventLogEntryGetterList)
                {
                    VRCModLogger.Log("[RamExploitPatcher]  - [" + fi.FieldType + "] " + fi.Name);
                    if (fi.FieldType == typeof(long))
                    {
                        VRCModLogger.Log("[RamExploitPatcher] TYPE MATCH !");
                        eventLogEntryGetter = fi;
                        break;
                    }
                }
            }
            return (long)eventLogEntryGetter.GetValue(eventLogEntry);
        }
    }
}
